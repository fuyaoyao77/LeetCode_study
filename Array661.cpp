//661. 图片平滑器



/*
包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。

示例 1:

输入:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
输出:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
注意:

给定矩阵中的整数范围为 [0, 255]。
矩阵的长和宽的范围均为 [1, 150]。


显示详情
执行用时 :
100 ms
, 在所有 C++ 提交中击败了
48.43%
的用户
内存消耗 :
19.1 MB
, 在所有 C++ 提交中击败了
100.00%
的用户
炫耀一下:

*/

class Solution {
public:
    vector<vector<int>> imageSmoother(vector<vector<int>>& M) {
        int i, j, m = M.size(), n = M[0].size();
        if(m == 1 && n == 1) return M;
        vector<vector<int>> ave = M;
        if(m == 1 && n > 1){
            ave[0][0] = (M[0][0] + M[0][1])/2;
            ave[0][n-1] = (M[0][n-1] + M[0][n-2])/2;
            for(i = 1; i < n - 1; i++){
            ave[0][i] = (M[0][i-1] + M[0][i] + M[0][i+1])/3;
            }
            return ave;
        }
        if(m > 1 && n == 1){
            ave[0][0] = (M[0][0] + M[1][0])/2;
            ave[m-1][0] = (M[m-2][0] + M[m-1][0])/2;
            for(i = 1; i < m - 1; i++){
            ave[i][0] = (M[i-1][0] + M[i][0] + M[i+1][0])/3;
            }
            return ave;
        }       
        ave[0][0] = (M[0][0] + M[0][1] + M[1][0] + M[1][1])/4;
        ave[0][n-1] = (M[0][n-1] + M[0][n-2] + M[1][n-1] + M[1][n-2])/4;
        ave[m-1][0] =  (M[m-1][0] + M[m-2][0] + M[m-1][1] + M[m-2][1])/4;
        ave[m-1][n-1] = (M[m-1][n-1] + M[m-2][n-1] + M[m-2][n-2] + M[m-1][n-2])/4;
        for(i = 1; i < n - 1; i++){
            ave[0][i] = (M[0][i-1] + M[0][i] + M[0][i+1] + M[1][i-1] + M[1][i] + M[1][i+1] )/6;
        }
        for(i = 1; i < n - 1; i++){
            ave[m-1][i] = (M[m-1][i-1] + M[m-1][i] + M[m-1][i+1] + M[m-2][i-1] + M[m-2][i] + M[m-2][i+1] )/6;
        }
        for(j = 1; j < m - 1; j++){
            ave[j][0] = (M[j][0] + M[j-1][0] + M[j+1][0] + M[j][1] + M[j-1][1] + M[j+1][1] )/6;
        }
        for(j = 1; j < m - 1; j++){
            ave[j][n-1] = (M[j-1][n-1] + M[j][n-1] + M[j+1][n-1] + M[j-1][n-2] + M[j][n-2] + M[j+1][n-2] )/6;
        }
        for(i = 1; i < m - 1; i++){
            for(j = 1; j < n - 1; j++){
                ave[i][j] = (M[i-1][j-1] + M[i-1][j] + M[i-1][j+1] + M[i][j-1] + M[i][j] + M[i][j+1] + M[i+1][j-1] + M[i+1][j] + M[i+1][j+1] )/9;
            }
        }
        return ave;
    }
};


